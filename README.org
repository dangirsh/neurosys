* About

This is my computing configuration, organized in a literate Org file.

NixOS + XMonad + Doom Emacs

Currently testing on a remote Linode instance.

** Inspirations

- https://github.com/willbush/system
- https://github.com/malloc47/config
- https://github.com/jwiegley/nix-config
- https://github.com/hlissner/dotfiles

** Helpful Resources

- https://www.gwern.net/Choosing-Software
- https://www.malloc47.com/migrating-to-nixos/
- https://www.nmattia.com/posts/2018-03-21-nix-reproducible-setup-linux-macos.html
- https://christine.website/blog/nixos-desktop-flow-2020-04-25

* Deployment

** Directory setup

#+begin_src sh :dir /ssh:root@nixos-dev:/root/ :async yes :results output
mkdir -p /etc/nixos/nix
mkdir -p /etc/nixos/.xmonad
#+end_src

** Tangle

#+begin_src emacs-lisp
(org-babel-tangle)
#+end_src

#+RESULTS:
| /ssh:root@nixos-dev:/etc/nixos/.xmonad/xmonad.hs | /ssh:root@nixos-dev:/etc/nixos/nix/sources.json | /ssh:root@nixos-dev:/etc/nixos/nix/sources.nix | /ssh:root@nixos-dev:/etc/nixos/home.nix | /ssh:root@nixos-dev:/etc/nixos/configuration.nix | /ssh:root@nixos-dev:/etc/nixos/hardware-configuration.nix |

** Build

#+begin_src sh :dir /ssh:root@nixos-dev:/root/ :async yes :results output
nixos-rebuild switch
#+end_src

[[elisp:(progn (save-excursion (find-file "/ssh:root@nixos-dev://")  (compile "nixos-rebuild switch")) (switch-to-buffer "*compilation*"))][nixos-rebuild switch]]

[[elisp:(find-file "/ssh:root@nixos-dev:/")][test]]

* Install NixOS

Followed:
https://www.linode.com/docs/tools-reference/custom-kernels-distros/install-nixos-on-linode/

* Add channels

One the Linode instance

#+BEGIN_SRC sh
NIXOS_VERSION=20.03

nix-channel --add "https://nixos.org/channels/nixos-${NIXOS_VERSION}" nixos
nix-channel --add "https://github.com/rycee/home-manager/archive/release-${NIXOS_VERSION}.tar.gz" home-manager
nix-channel --add "https://nixos.org/channels/nixpkgs-unstable" nixpkgs-unstable

nix-channel update
#+END_SRC

* Nixos Config
** hardware-configuration.nix

[[file:/ssh:root@nixos-dev:/etc/nixos/hardware-configuration.nix][Remote /etc/nixos/hardware-configuration.nix]]

#+begin_src nix :tangle /ssh:root@nixos-dev:/etc/nixos/hardware-configuration.nix :comments link
# Do not modify this file!  It was generated by ‘nixos-generate-config’
# and may be overwritten by future invocations.  Please make changes
# to /etc/nixos/configuration.nix instead.
{ config, lib, pkgs, ... }:

{
  imports =
    [ <nixpkgs/nixos/modules/profiles/qemu-guest.nix>
    ];

  boot.initrd.availableKernelModules = [ "virtio_pci" "ahci" "sd_mod" ];
  boot.initrd.kernelModules = [ ];
  boot.kernelModules = [ ];
  boot.extraModulePackages = [ ];

  fileSystems."/" =
    { device = "/dev/disk/by-uuid/bf38bdde-34dd-4d57-9bfe-07de465f0f29";
      fsType = "ext4";
    };

  swapDevices =
    [ { device = "/dev/disk/by-uuid/7596d600-d2c6-4d77-b138-7f595283af00"; }
    ];

  nix.maxJobs = lib.mkDefault 1;
}
#+end_src

** configuration.nix

[[file:/ssh:root@nixos-dev:/etc/nixos/configuration.nix][Remote /etc/nixos/configuration.nix]]


#+BEGIN_SRC nix :tangle /ssh:root@nixos-dev:/etc/nixos/configuration.nix :comments link
{ config, pkgs, ... }:
let
  sources = import ./nix/sources.nix;
  # ghcide-nix = import sources."ghcide-nix" { };
in {
  imports =
    [ ./hardware-configuration.nix
      "${builtins.fetchTarball https://github.com/rycee/home-manager/archive/release-20.03.tar.gz}/nixos"
    ];

  nixpkgs.config = {
    # Allow unfree, which is required for some drivers.
    allowUnfree = true;
  };

  nix = {
    useSandbox = true;
    autoOptimiseStore = true;
    # FIXME: Update this after moving to dev server.
    # maxJobs = 1; # should be 1 per CPU logical core
    # binaryCaches = [
    #   "https://cache.nixos.org/"
    #   "https://ghcide-nix.cachix.org"
    #   "https://hercules-ci.cachix.org"
    #   "https://iohk.cachix.org"
    #   "https://nix-tools.cachix.org"
    # ];
    # binaryCachePublicKeys = [
    #   "ghcide-nix.cachix.org-1:ibAY5FD+XWLzbLr8fxK6n8fL9zZe7jS+gYeyxyWYK5c="
    #   "hercules-ci.cachix.org-1:ZZeDl9Va+xe9j+KqdzoBZMFJHVQ42Uu/c/1/KMC5Lw0="
    #   "iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo="
    #   "nix-tools.cachix.org-1:ebBEBZLogLxcCvipq2MTvuHlP7ZRdkazFSQsbs0Px1A="
    # ];
    # gc = {
    #   automatic = true;
    #   dates = "23:00";
    #   options = "--delete-older-than 30d";
    # };
  };

  time.timeZone = "America/Los_Angeles";

  boot = {
    cleanTmpDir = true;

    loader = {
      timeout = 1; # Timeout (in seconds) until loader boots the default menu item.
      grub = {
        enable = true;
        version = 2;
        device = "nodev";
        copyKernels = true;
        fsIdentifier = "provided";
        extraConfig = "serial; terminal_input serial; terminal_output serial";
      };
      systemd-boot.enable = false;
      efi.canTouchEfiVariables = false;

    };
  };

  networking.useDHCP = false;
  networking.usePredictableInterfaceNames = false;
  networking.interfaces.eth0.useDHCP = true;
  networking.firewall.enable = true;
  # networking.networkmanager.enable = true;
  networking.hostName = "nixos-dev";

  services = {

    xserver = {
      enable = true;
      layout = "us";

      windowManager.xmonad = {
        enable = true;
        enableContribAndExtras = true;
        extraPackages = haskellPackges: [
          haskellPackges.xmonad-contrib
          haskellPackges.xmonad-extras
          haskellPackges.xmonad
        ];
      };

      displayManager = {
        defaultSession = "none+xmonad";
        lightdm.enable = true;
      };
      desktopManager.xterm.enable = false;
    };
  };

  # virtualisation.docker.enable = true;

  environment.systemPackages = with pkgs; [
    coreutils
    binutils
    curl
    wget
    zip
    unzip
    # docker
    # docker-compose
    # ghcide-nix.ghcide-ghc865
    tree
    git
    killall
    unzip
    wget
    sshfs
    gnumake
    mtr
    sysstat
    htop
  ];

  fonts = {
    enableFontDir = true;
    enableGhostscriptFonts = true;
    fonts = with pkgs; [
      corefonts
      hack-font
    ];
  };

  system.stateVersion = "20.03";

  users.mutableUsers = false;

  users.extraUsers.dan = {
    isNormalUser = true;
    uid = 1000;
    createHome = true;
    home = "/home/dan";
    description = "Dan Girshovich";
    extraGroups = [
      "audio"
      "networkmanager"
      "systemd-journal"
      "vboxusers"
      "video"
      "wheel"
    ];
  };

  home-manager.users.dan = import ./home.nix ;

  services.openssh = {
    enable = true;
    forwardX11 = true;
    permitRootLogin = "without-password";
    passwordAuthentication = false;
  };

  users.users.dan.openssh.authorizedKeys.keys = [
    "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+yJ5sv7iO9PBuozfmitR0JJfqDsJ7w+rlryq5CwdatO3tkRdR5dMYdFTFCeHbmeakPTC/uys08fziEUXh3DL206jDKQEMBoMGXNowZHyYzr25nIogHbveqeNTgP8jsTw5uBaJu8LFzHHey4Sw9WlRrvIqguUT5jB3omZh8yDWcxTrTJlTsN2TM3HILvirfVwBkD2uNTDdd5LplbZhx6x87VCs6ZNYhBjJ4CPcO4zTQuEdyyxUHEgtMkYgrS4Jb/Kl6Tleftlh55E74SZ3XXnw3lWdH9ra8ewH265iqNr/RwysagnalslBZDLl8yJcrMsCVi4tPrZZc4vaeCsIWK4X dan@x1carbon"
  ];

  programs.ssh.startAgent = true;

  programs.x2goserver.enable = true;

}
#+END_SRC

** home.nix

[[file:/ssh:root@nixos-dev:/etc/nixos/home.nix][Remote /etc/nixos/home.nix]]

#+BEGIN_SRC nix :tangle /ssh:root@nixos-dev:/etc/nixos/home.nix :comments link
{ config, pkgs, ... }:

let
  homeDir = builtins.getEnv "HOME";
  syncDir = builtins.toPath("${homeDir}/Sync");
  sources = import ./nix/sources.nix;
  nixos20_03 = import sources."nixpkgs-20.03" { };
  emacs-overlay = import (import ./nix/sources.nix)."emacs-overlay";
in {
  imports = [ ];

  home.stateVersion = "20.03";

  nixpkgs.config = {
    allowUnfree = true;
    packageOverrides = pkgs: { stable = nixos20_03; };
  };

  nixpkgs.overlays = [ emacs-overlay ];

  # services.emacs.enable = true;
  # programs.emacs = {
  #   enable = true;
  #   # Compile with imagemagick support so I can resize images.
  #   # package = pkgs.emacsGit.override { inherit (pkgs) imagemagick; };
  # };

  # Let Home Manager install and manage itself.
  programs.home-manager.enable = true;

  home.sessionVariables = {
    EDITOR = "emacsclient --create-frame --alternate-editor emacs";
    PASSWORD_STORE_DIR = "${syncDir}/.password-store";
    GNUPGHOME = "${syncDir}/.gnupg/";
    # GTK2_RC_FILES="${homeDir}/.gtkrc-2.0";
    # https://github.com/xmonad/xmonad/issues/126
    _JAVA_AWT_WM_NONREPARENTING = "1";
  };

  # gtk = {
  #   enable = true;
  #   iconTheme = {
  #     name = "Adwaita";
  #     package = pkgs.gnome3.adwaita-icon-theme;
  #   };
  #   theme = {
  #     name = "Adwaita-dark";
  #     package = pkgs.gnome3.gnome_themes_standard;
  #   };
  # };

  home.file = {
    ".xmonad/xmonad.hs".source = .xmonad/xmonad.hs;
  };

  xdg.enable = true;

  home.packages = with pkgs; [
    # Haskell dev
    # haskellPackages.ghcid
    # haskellPackages.hakyll
    # haskellPackages.hasktags
    # haskellPackages.hlint
    # haskellPackages.hoogle
    # haskellPackages.hpack
    # cabal-install
    # stable.haskellPackages.apply-refact # used by hlint-refactor
    # stable.haskellPackages.brittany

    # cabal2nix
    # cachix
    # nix-prefetch-git
    # nixfmt

    rofi

    gnupg

    pavucontrol
    # syncthing-cli # provides stcli
    # vlc
    xdotool

    (pass.withExtensions (exts: [
      exts.pass-otp
      exts.pass-genphrase
    ]))

    gitAndTools.hub

    firefox-beta-bin
    # firefox-bin

    # direnv

    # sbcl
    # lispPackages.quicklisp

    # clojure
    # joker
    # leiningen

    # julia_13

    ## Doom dependencies
    emacsGit

    git
    (ripgrep.override {withPCRE2 = true;})
    gnutls              # for TLS connectivity

    ## Optional dependencies
    fd                  # faster projectile indexing
    imagemagick         # for image-dired
    pinentry_emacs

    ## Module dependencies
    # :tools lookup & :lang org +roam
    sqlite
    # :lang latex & :lang org (latex previews)
    texlive.combined.scheme-tetex
  ];

  programs.git = {
    enable = true;
    userName = "Dan Girshovich";
    userEmail = "dan.girsh@gmail.com";
  };

  programs.direnv.enable = true;

  programs.ssh = {
    enable = true;

    controlMaster  = "auto";
    controlPath    = "/tmp/ssh-%u-%r@%h:%p";
    controlPersist = "1800";

    forwardAgent = true;
    serverAliveInterval = 60;

    hashKnownHosts = true;
    userKnownHostsFile = "${homeDir}/.ssh/known_hosts";

    matchBlocks = {
      droplet = {
        hostname = "45.55.5.197";
        identityFile = "${homeDir}/.ssh/id_rsa";
        user = "dgirsh";
      };
      dangirsh = {
        host = "dangirsh.org";
        hostname = "ssh.phx.nearlyfreespeech.net";
        identityFile = "${homeDir}/.ssh/id_rsa";
        user = "dangirsh_dangirsh";
      };
      nixos-dev = {
        hostname = "45.79.58.229";
        identityFile = "${homeDir}/.ssh/id_rsa";
        user = "dan";
      };
    };
  };

  # services.redshift = {
  #   enable = true;
  #   latitude = "33";
  #   longitude = "-97";
  #   temperature.day = 6500;
  #   temperature.night = 3000;
  # };

  # https://www.reddit.com/r/emacsporn/comments/euf7m8/doomoutrunelectric_theme_xmonad_nixos/
  # https://github.com/willbush/system/blob/371cfa9933f24bca585a3c6c952c41c864d97aa0/nixos/home.nix#L178
  # services.compton = {
  #     enable = true;
  #     fade = true;
  #     backend = "xrender";
  #     fadeDelta = 1;
  #     # I only want transparency for a couple of applications.
  #     opacityRule = [
  #       "90:class_g ?= 'emacs' && focused"
  #       "75:class_g ?= 'emacs' && !focused"
  #       "90:class_g ?= 'alacritty' && focused"
  #       "75:class_g ?= 'alacritty' && !focused"
  #     ];
  #   };

  # services.syncthing.enable = true;
  # services.lorri.enable = true;
}
#+END_SRC

** niv

#+begin_src json :tangle /ssh:root@nixos-dev:/etc/nixos/nix/sources.json
{
    "emacs-overlay": {
        "branch": "master",
        "description": "Bleeding edge emacs overlay [maintainer=@adisbladis] ",
        "homepage": "",
        "owner": "nix-community",
        "repo": "emacs-overlay",
        "rev": "0feda8b31b52f3ea008555dfe79dba3989d3e585",
        "sha256": "1ijr9pl0czzbgj35vj8kq4xvcana6w24ljcmzriz7cyxln4pgvln",
        "type": "tarball",
        "url": "https://github.com/nix-community/emacs-overlay/archive/0feda8b31b52f3ea008555dfe79dba3989d3e585.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "ghcide-nix": {
        "branch": "master",
        "description": "Nix installation for ghcide",
        "homepage": "https://github.com/digital-asset/ghcide",
        "owner": "cachix",
        "repo": "ghcide-nix",
        "rev": "f940ec611cc6914693874ee5e024eba921cab19e",
        "sha256": "0vri0rivdzjvxrh6lzlwwkh8kzxsn82jp1c2w5rqzhp87y6g2k8z",
        "type": "tarball",
        "url": "https://github.com/cachix/ghcide-nix/archive/f940ec611cc6914693874ee5e024eba921cab19e.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    },
    "nixpkgs-20.03": {
        "branch": "release-20.03",
        "description": "A read-only mirror of NixOS/nixpkgs tracking the released channels. Send issues and PRs to",
        "homepage": "https://github.com/NixOS/nixpkgs",
        "owner": "NixOS",
        "repo": "nixpkgs",
        "rev": "7829e5791ba1f6e6dbddbb9b43dda72024dd2bd1",
        "sha256": "0hs9swpz0kibjc8l3nx4m10kig1fcjiyy35qy2zgzm0a33pj114w",
        "type": "tarball",
        "url": "https://github.com/NixOS/nixpkgs/archive/7829e5791ba1f6e6dbddbb9b43dda72024dd2bd1.tar.gz",
        "url_template": "https://github.com/<owner>/<repo>/archive/<rev>.tar.gz"
    }
}
#+end_src


#+begin_src nix :tangle /ssh:root@nixos-dev:/etc/nixos/nix/sources.nix :comments link
# This file has been generated by Niv.

# A record, from name to path, of the third-party packages
with rec
{
  pkgs =
    if hasNixpkgsPath
    then
        if hasThisAsNixpkgsPath
        then import (builtins_fetchTarball { inherit (sources_nixpkgs) url sha256; }) {}
        else import <nixpkgs> {}
    else
        import (builtins_fetchTarball { inherit (sources_nixpkgs) url sha256; }) {};

  sources_nixpkgs =
    if builtins.hasAttr "nixpkgs" sources
    then sources.nixpkgs
    else abort
    ''
        Please specify either <nixpkgs> (through -I or NIX_PATH=nixpkgs=...) or
        add a package called "nixpkgs" to your sources.json.
    '';

  # fetchTarball version that is compatible between all the versions of Nix
  builtins_fetchTarball =
      { url, sha256 }@attrs:
      let
        inherit (builtins) lessThan nixVersion fetchTarball;
      in
        if lessThan nixVersion "1.12" then
          fetchTarball { inherit url; }
        else
          fetchTarball attrs;

  # fetchurl version that is compatible between all the versions of Nix
  builtins_fetchurl =
      { url, sha256 }@attrs:
      let
        inherit (builtins) lessThan nixVersion fetchurl;
      in
        if lessThan nixVersion "1.12" then
          fetchurl { inherit url; }
        else
          fetchurl attrs;

  # A wrapper around pkgs.fetchzip that has inspectable arguments,
  # annoyingly this means we have to specify them
  fetchzip = { url, sha256 }@attrs: pkgs.fetchzip attrs;

  # A wrapper around pkgs.fetchurl that has inspectable arguments,
  # annoyingly this means we have to specify them
  fetchurl = { url, sha256 }@attrs: pkgs.fetchurl attrs;

  hasNixpkgsPath = (builtins.tryEval <nixpkgs>).success;
  hasThisAsNixpkgsPath =
    (builtins.tryEval <nixpkgs>).success && <nixpkgs> == ./.;

  sources = builtins.fromJSON (builtins.readFile ./sources.json);

  mapAttrs = builtins.mapAttrs or
    (f: set: with builtins;
      listToAttrs (map (attr: { name = attr; value = f attr set.${attr}; }) (attrNames set)));

  # borrowed from nixpkgs
  functionArgs = f: f.__functionArgs or (builtins.functionArgs f);
  callFunctionWith = autoArgs: f: args:
    let auto = builtins.intersectAttrs (functionArgs f) autoArgs;
    in f (auto // args);

  getFetcher = spec:
    let fetcherName =
      if builtins.hasAttr "type" spec
      then builtins.getAttr "type" spec
      else "builtin-tarball";
    in builtins.getAttr fetcherName {
      "tarball" = fetchzip;
      "builtin-tarball" = builtins_fetchTarball;
      "file" = fetchurl;
      "builtin-url" = builtins_fetchurl;
    };
};
# NOTE: spec must _not_ have an "outPath" attribute
mapAttrs (_: spec:
  if builtins.hasAttr "outPath" spec
  then abort
    "The values in sources.json should not have an 'outPath' attribute"
  else
    if builtins.hasAttr "url" spec && builtins.hasAttr "sha256" spec
    then
      spec //
      { outPath = callFunctionWith spec (getFetcher spec) { }; }
    else spec
  ) sources
#+end_src


* Emacs Config

My [[https://github.com/mindlike/.doom.d][Doom Emacs Configuration]] + a forked [[https://github.com/dangirsh/doom-emacs][Doom Emacs]] are tracked here as git submodules.

Until projects like [[https://github.com/vlaci/nix-doom-emacs][nix-doom-emacs]] are stable, I'm *not yet* tracking my Emacs packages / config in Nix. For now, I track known-good commits via submodules / [[https://github.com/raxod502/straight.el][straight.el]], and tie them to external dependencies (all managed by Nix) in this repo. If you know a better way to do this, please [[https://dangirsh.org/contact.html][let me know]].

Emacs itself is tracked via the [[https://github.com/nix-community/emacs-overlay][emacs-overlay]], which is version pinned via [[https://github.com/nmattia/niv][niv]] in sources.json above.

Here, I just copy [[file:.emacs.d/][.emacs.d]] and [[file:.doom.d/][.doom.d]] into target's ~$HOME~.

#+begin_src sh :async yes
scp -r .emacs.d root@nixos-dev:/home/dan
scp -r .doom.d root@nixos-dev:/home/dan
#+end_src

#+RESULTS:


* XMonad

#+begin_src haskell :tangle /ssh:root@nixos-dev:/etc/nixos/.xmonad/xmonad.hs :comments link
import XMonad
import XMonad.Hooks.SetWMName
import XMonad.Hooks.EwmhDesktops
import XMonad.Layout.Grid
import XMonad.Layout.ResizableTile
import XMonad.Layout.NoBorders
import XMonad.Layout.Fullscreen
import XMonad.Actions.CycleWS (nextWS, prevWS, toggleWS)
import XMonad.Util.Run (safeSpawnProg)
import XMonad.Layout.Minimize
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.ManageHelpers
import XMonad.Hooks.UrgencyHook
import XMonad.Actions.WindowGo (runOrRaise)
import qualified XMonad.StackSet as W

import qualified Data.Map as M
import Data.Monoid
import Data.Default (def)

main :: IO ()
main = xmonad $
  withUrgencyHook NoUrgencyHook $
  ewmh $
  fullscreenSupport def {
    focusedBorderColor = "#5699AF"
  , normalBorderColor = "#cccccc"
  -- , terminal = "emacs-vterm"
  , terminal = "xterm"
  , borderWidth = 2
  , layoutHook = myLayoutHook $
                 avoidStruts $
                 minimize $
                 (ResizableTall 1 (3/100) (1/2) []
                   ||| Mirror (ResizableTall 1 (3/100) (1/2) [])
                   ||| noBorders Full
                   ||| Grid)
  , workspaces = map show $ [1..9] ++ [0 :: Int]
  , modMask = mod4Mask
  , handleEventHook = ewmhDesktopsEventHook <+> docksEventHook
  , manageHook = manageHook def <+> myManageHook
  , startupHook = do
      -- http://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Hooks-SetWMName.html
      setWMName "LG3D"
      windows $ W.greedyView "1"
      spawn "~/.xmonad/startup-hook"
  } `additionalKeys` myKeys

myKeys :: XConfig Layout -> M.Map (KeyMask, KeySym) (X ())
myKeys XConfig {XMonad.modMask = m, terminal = term} = M.fromList $ [
    ((m .|. shiftMask .|. mod1Mask, xK_r), safeSpawnProg "reboot")
  , ((m,                            xK_p), safeSpawnProg "rofi -show drun -modi drun -show-icons -matching fuzzy"
  , ((m,                            xK_b), safeSpawnProg "rofi -show window -show-icons -matching fuzzy"
  , ((m,                            xK_n), spawn "$EDITOR")
  , ((m .|. shiftMask,              xK_n), spawn "~/.emacs.d/bin/doom run")
  , ((m .|. shiftMask .|. mod1Mask, xK_t), sendMessage ToggleStruts)
  , ((m .|. shiftMask .|. mod1Mask, xK_o), safeSpawnProg "xtrlock -b")
  , ((m .|. shiftMask .|. mod1Mask, xK_i), spawn "xmonad --recompile && xmonad --restart")
  , ((m,                            xK_Tab), windows W.focusDown)
  , ((m .|. shiftMask,              xK_a), windows W.swapMaster)                   --Swap the focused window and the master window
  , ((m .|. shiftMask,              xK_j), prevWS)
  , ((m .|. shiftMask,              xK_k), nextWS)
  , ((m .|. shiftMask,              xK_h), sendMessage MirrorShrink)               --MirrorShrink the master area
  , ((m .|. shiftMask,              xK_l), sendMessage MirrorExpand)               --MirrorExpand the master area
  , ((m,                            xK_m), withFocused minimizeWindow)             --Minimize window
  , ((m .|. shiftMask,              xK_m), sendMessage RestoreNextMinimizedWin)    --Restore window
  , ((m .|. shiftMask,              xK_f), fullFloatFocused)                       --Push window into full screen
  , ((m,                            xK_comma), toggleWS)                           --Toggle to the workspace displayed previously
  , ((m .|. shiftMask,              xK_Up), spawn "amixer sset Master 5%+")
  , ((m .|. shiftMask,              xK_Down),spawn "amixer sset Master 5%-")
  ] ++ [((m .|. mod4Mask, key), screenWorkspace sc
          >>= flip whenJust (windows . f))
       | (key, sc) <- zip [xK_e, xK_w, xK_r] [0..]
       , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]
    where
        fullFloatFocused = withFocused $ \f -> windows =<< appEndo `fmap` runQuery doFullFloat f
        rectFloatFocused = withFocused $ \f -> windows =<< appEndo `fmap` runQuery (doRectFloat $ W.RationalRect 0.05 0.05 0.9 0.9) f


myManageHook :: ManageHook
myManageHook = composeAll . concat $
    [
      -- FIXME: Add float for ivy/counsel after switching back to ivy posframe
      [ title =? t --> doFloat | t <- ["Helm"] ],
      [ className =? c --> doFloat | c <- ["Tk"]]
    ]
#+end_src

